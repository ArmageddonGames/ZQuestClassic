Compiling 'bumper.zs'
Pass 1: Parsing
Pass 2: Preprocessing
Pass 3: Registration
Pass 4: Analyzing Code
Pass 5: Checking code paths
Pass 6: Generating object code
Pass 7: Assembling
Success!
Compile finished with exit code '0' (success)

PUSHR d0; void run(int) Params
PUSHR REFFFC; void run(int) Body Start
PUSHARGSV 0,0.0007
SETR d4,SP
LOADD d2,7
PUSHR d2
POP REFFFC
SETR d2,DATA
STORED d2,6
SETV d2,0
STORED d2,5
SETV d2,0
STORED d2,4
SETV d2,0
PUSHR d2
LOADD d2,7
POP d3
PUSHR d2
PUSHR d3
SETV d2,7
PUSHR d2
POP d0
POP d2
POP REFFFC
SETR FFINITDD,d2
SETV d2,0
STORED d2,3
SETV d2,0
STORED d2,2
SETV d2,0
STORED d2,1
PUSHARGSR d4,0.0002; if() #9270 Test AND while(true) #9268 Body [Opt:AlwaysOn] Start AND Int.Func[int Distance(int, int, int, int)] Params Start
LOADD d2,7; UsrFunc[int CenterX(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterX(FFC)] Params End
CALLFUNC 0.0864; UsrFunc[int CenterX(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
LOADD d2,7; UsrFunc[int CenterY(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterY(FFC)] Params End
CALLFUNC 0.0888; UsrFunc[int CenterY(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0854; UsrFunc[int CenterLinkX()] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0859; UsrFunc[int CenterLinkY()] Call
POP d4
PUSHR d2; Int.Func[int Distance(int, int, int, int)] Params End
CALLFUNC 0.0485; Int.Func[int Distance(int, int, int, int)] Call
POP d4
PUSHR d2
LOADD d2,7
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
MULTV d2,8
ADDV d2,2
POP d3
COMPARER d3,d2
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 72
SETR d2,LINKZ
COMPAREV d2,0
SETTRUEI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 119; Test 'if'
LOADD d2,7; if() #9272 Test AND if() #9270 Body Start
PUSHR d2
SETV d2,7
PUSHR d2
POP d0
POP REFFFC
SETR d2,FFINITDD
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 116; Test 'if'
SETV d2,76; InlineFunc[void Game->PlaySound(int)] Params AND if() #9272 Body Start
PLAYSOUNDR d2; InlineFunc[void Game->PlaySound(int)] Body
PUSHARGSR d4,0.0002; UsrFunc[int Angle(int, int, int, int)] Params Start
LOADD d2,7; UsrFunc[int CenterX(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterX(FFC)] Params End
CALLFUNC 0.0864; UsrFunc[int CenterX(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
LOADD d2,7; UsrFunc[int CenterY(FFC)] Params Start
PUSHR d2; UsrFunc[int CenterY(FFC)] Params End
CALLFUNC 0.0888; UsrFunc[int CenterY(FFC)] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0854; UsrFunc[int CenterLinkX()] Call
POP d4
PUSHR d2
PUSHR d4
CALLFUNC 0.0859; UsrFunc[int CenterLinkY()] Call
POP d4
PUSHR d2; UsrFunc[int Angle(int, int, int, int)] Params End
CALLFUNC 0.0531; UsrFunc[int Angle(int, int, int, int)] Call
POP d4
STORED d2,5
LOADD d2,8
STORED d2,4
SETV d2,16
STORED d2,3; if() #9272 Body End
PUSHR d4
CALLFUNC 0.0912; UsrFunc[void NoAction()] Call
POP d4; if() #9270 Body End
LOADD d2,4; if() #9273 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 153; Test 'if'
LOADD d2,2; if() #9273 Body Start
PUSHR d2
PUSHR d4
PUSHV 3; UsrFunc[int VectorX(int, int)] Params Start
LOADD d2,5
PUSHR d2; UsrFunc[int VectorX(int, int)] Params End
CALLFUNC 0.0957; UsrFunc[int VectorX(int, int)] Call
POP d4
POP d3
ADDR d2,d3
STORED d2,2
LOADD d2,1
PUSHR d2
PUSHR d4
PUSHV 3; UsrFunc[int VectorY(int, int)] Params Start
LOADD d2,5
PUSHR d2; UsrFunc[int VectorY(int, int)] Params End
CALLFUNC 0.0968; UsrFunc[int VectorY(int, int)] Call
POP d4
POP d3
ADDR d2,d3
STORED d2,1
LOADD d2,4
PUSHR d2
SUBV d2,1
STORED d2,4
POP d2; if() #9273 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9274 Test
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 305; Test 'if'
SETV d2,0; for() #9275 setup AND if() #9274 Body Start
STORED d2,0
LOADD d2,0; for() #9275 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 174
LOADD d2,2
COMPAREV d2,-1
SETLESSI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 233; for() #9275 TestFail?
PUSHR d4; if() #9279 Test AND for() #9275 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 2
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0551; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 201; Test 'if'
SETR d2,LINKX; if() #9279 Body Start
PUSHR d2
SUBV d2,1
PUSHR d2
POP d2
SETR LINKX,d2
POP d2
LOADD d2,2
PUSHR d2
ADDV d2,1
STORED d2,2
POP d2
GOTO 227; if() #9279 Body End
LOADD d2,1; InlineFunc[int Abs(int)] Params AND if() #9281 Test AND if() #9279 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 225; Test 'if'
LOADD d2,1; if() #9281 Body Start
PUSHR d2
PUSHR d4
LOADD d2,1; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0979; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,2; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,1; if() #9281 Body End
SETV d2,0
STORED d2,2; if() #9279 Else End
LOADD d2,0; for() #9275 Body End AND for() #9275 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 163; for() #9275 End
SETV d2,0; for() #9282 setup
STORED d2,0
LOADD d2,0; for() #9282 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 246
LOADD d2,2
COMPAREV d2,1
SETMOREI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 305; for() #9282 TestFail?
PUSHR d4; if() #9286 Test AND for() #9282 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 3
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0551; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 273; Test 'if'
SETR d2,LINKX; if() #9286 Body Start
PUSHR d2
ADDV d2,1
PUSHR d2
POP d2
SETR LINKX,d2
POP d2
LOADD d2,2
PUSHR d2
SUBV d2,1
STORED d2,2
POP d2
GOTO 299; if() #9286 Body End
LOADD d2,1; InlineFunc[int Abs(int)] Params AND if() #9288 Test AND if() #9286 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 297; Test 'if'
LOADD d2,1; if() #9288 Body Start
PUSHR d2
PUSHR d4
LOADD d2,1; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0979; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,2; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,1; if() #9288 Body End
SETV d2,0
STORED d2,2; if() #9286 Else End
LOADD d2,0; for() #9282 Body End AND for() #9282 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 235; for() #9282 End
LOADD d2,1; if() #9274 Body End AND InlineFunc[int Abs(int)] Params AND if() #9289 Test
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 456; Test 'if'
SETV d2,0; for() #9290 setup AND if() #9289 Body Start
STORED d2,0
LOADD d2,0; for() #9290 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 326
LOADD d2,1
COMPAREV d2,-1
SETLESSI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 385; for() #9290 TestFail?
PUSHR d4; if() #9294 Test AND for() #9290 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHV 0
PUSHV 1
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0551; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 353; Test 'if'
SETR d2,LINKY; if() #9294 Body Start
PUSHR d2
SUBV d2,1
PUSHR d2
POP d2
SETR LINKY,d2
POP d2
LOADD d2,1
PUSHR d2
ADDV d2,1
STORED d2,1
POP d2
GOTO 379; if() #9294 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9296 Test AND if() #9294 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 377; Test 'if'
LOADD d2,2; if() #9296 Body Start
PUSHR d2
PUSHR d4
LOADD d2,2; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0979; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,1; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,2; if() #9296 Body End
SETV d2,0
STORED d2,1; if() #9294 Else End
LOADD d2,0; for() #9290 Body End AND for() #9290 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 315; for() #9290 End
SETV d2,0; for() #9297 setup
STORED d2,0
LOADD d2,0; for() #9297 LoopTest
COMPAREV d2,4
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 398
LOADD d2,1
COMPAREV d2,1
SETMOREI d2
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
GOTOTRUE 456; for() #9297 TestFail?
PUSHR d4; if() #9301 Test AND for() #9297 Body Start
PUSHR LINKX; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params Start
PUSHR LINKY
PUSHARGSV 1,0.0002
PUSHV 0; UsrFunc[bool CanWalk(int, int, int, int, bool)] Params End
CALLFUNC 0.0551; UsrFunc[bool CanWalk(int, int, int, int, bool)] Call
POP d4
COMPAREV d2,0
GOTOTRUE 424; Test 'if'
SETR d2,LINKY; if() #9301 Body Start
PUSHR d2
ADDV d2,1
PUSHR d2
POP d2
SETR LINKY,d2
POP d2
LOADD d2,1
PUSHR d2
SUBV d2,1
STORED d2,1
POP d2
GOTO 450; if() #9301 Body End
LOADD d2,2; InlineFunc[int Abs(int)] Params AND if() #9303 Test AND if() #9301 Else Start
ABS d2; InlineFunc[int Abs(int)] Body
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 448; Test 'if'
LOADD d2,2; if() #9303 Body Start
PUSHR d2
PUSHR d4
LOADD d2,2; UsrFunc[int Sign(int)] Params Start
PUSHR d2; UsrFunc[int Sign(int)] Params End
CALLFUNC 0.0979; UsrFunc[int Sign(int)] Call
POP d4
PUSHR d2
LOADD d2,1; InlineFunc[int Abs(int)] Params Start
DIVV d2,2; InlineFunc[int Abs(int)] Params End
ABS d2; InlineFunc[int Abs(int)] Body
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
STORED d2,2; if() #9303 Body End
SETV d2,0
STORED d2,1; if() #9301 Else End
LOADD d2,0; for() #9297 Body End AND for() #9297 LoopIncrement
PUSHR d2
ADDV d2,1
STORED d2,0
POP d2
GOTO 387; for() #9297 End
LOADD d2,3; if() #9289 Body End AND if() #9304 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 468; Test 'if'
LOADD d2,3; if() #9304 Body Start
PUSHR d2
SUBV d2,1
STORED d2,3
POP d2; if() #9304 Body End
LOADD d2,6
PUSHR d2
LOADD d2,3; InlineFunc[untyped Floor(untyped)] Params Start
DIVV d2,4; InlineFunc[untyped Floor(untyped)] Params End
FLOOR d2; InlineFunc[untyped Floor(untyped)] Body
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
POP d3
PUSHR d2
PUSHR d3
POP d2
POP REFFFC
SETR DATA,d2
WAITFRAME; InlineFunc[void Waitframe()] Body AND while(true) #9268 Body [Opt:AlwaysOn] End
GOTO 32; while() #9268 End AND [Opt:NeverRet] AND void run(int) Body End
POP d2; Func[int Distance(int, int, int, int)] Body Start
POP d1
POP d0
POP d6
SETR d2,DISTANCE
RETURNFUNC; Func[int Distance(int, int, int, int)] Body End
SETR d4,SP; Func[int DirNormal(int)] Body Start
LOADD d2,0; switch() #4297 Key
SETR SWITCHKEY,d2; Store key
COMPAREV SWITCHKEY,8
GOTOTRUE 511; case '80000'
COMPAREV SWITCHKEY,9
GOTOTRUE 513; case '90000'
COMPAREV SWITCHKEY,10
GOTOTRUE 515; case '100000'
COMPAREV SWITCHKEY,11
GOTOTRUE 517; case '110000'
COMPAREV SWITCHKEY,12
GOTOTRUE 519; case '120000'
COMPAREV SWITCHKEY,13
GOTOTRUE 521; case '130000'
COMPAREV SWITCHKEY,14
GOTOTRUE 523; case '140000'
COMPAREV SWITCHKEY,15
GOTOTRUE 525; case '150000'
GOTO 527; switch() #4297 NoMatch
SETV d2,0; Case block AND return Start
GOTO 529; return End
SETV d2,5; Case block AND return Start
GOTO 529; return End
SETV d2,3; Case block AND return Start
GOTO 529; return End
SETV d2,7; Case block AND return Start
GOTO 529; return End
SETV d2,1; Case block AND return Start
GOTO 529; return End
SETV d2,6; Case block AND return Start
GOTO 529; return End
SETV d2,2; Case block AND return Start
GOTO 529; return End
SETV d2,4; Case block AND return Start
GOTO 529; return End
LOADD d2,0; Case block AND return Start
GOTO 529; return End
POPARGS d5,0.0001
RETURNFUNC; Func[int DirNormal(int)] Body End
SETR d4,SP; Func[int Angle(int, int, int, int)] Body Start
LOADD d2,1; InlineFunc[int ArcTan(int, int)] Params Start AND InlineFunc[int RadtoDeg(int)] Params Start AND return Start
PUSHR d2
LOADD d2,3
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,0
PUSHR d2
LOADD d2,2
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[int ArcTan(int, int)] Params End
POP d0; InlineFunc[int ArcTan(int, int)] Body Start
ARCTANR d2; InlineFunc[int ArcTan(int, int)] Body End
SETR d3,d2; InlineFunc[int RadtoDeg(int)] Params End
RADTODEG d2,d3; InlineFunc[int RadtoDeg(int)] Body
GOTO 549; return End
POPARGS d5,0.0004
RETURNFUNC; Func[int Angle(int, int, int, int)] Body End
PUSHARGSV 0,0.0004; Func[bool CanWalk(int, int, int, int, bool)] Body Start
SETR d4,SP
SETV d2,8
STORED d2,3
LOADD d2,8
ADDV d2,15
STORED d2,2
LOADD d2,7
ADDV d2,15
STORED d2,1
LOADD d2,4; if() #3622 Test
COMPAREV d2,0
GOTOTRUE 566; Test 'if'
SETV d2,0; if() #3622 Body Start
STORED d2,3; if() #3622 Body End
PUSHR d4; switch() #3623 Key
LOADD d2,6; UsrFunc[int DirNormal(int)] Params Start
PUSHR d2; UsrFunc[int DirNormal(int)] Params End
CALLFUNC 0.0491; UsrFunc[int DirNormal(int)] Call
POP d4
SETR SWITCHKEY,d2; Store key
COMPAREV SWITCHKEY,0
GOTOTRUE 581; case '0'
COMPAREV SWITCHKEY,1
GOTOTRUE 652; case '10000'
COMPAREV SWITCHKEY,2
GOTOTRUE 708; case '20000'
COMPAREV SWITCHKEY,3
GOTOTRUE 775; case '30000'
GOTO 839; switch() #3623 NoMatch
LOADD d2,7; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d2,d3
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0.0001
GOTOMORE 609
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 629
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
ADDV d2,8
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 648
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d1,d3; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 852; return End
LOADD d2,1; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
COMPAREV d2,176
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 673
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 689
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
ADDV d2,8
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 704
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,1
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 852; return End
LOADD d2,8; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
SETR d2,d3
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0.0001
GOTOMORE 736
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 756
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
ADDV d2,7
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 771
LOADD d2,8; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
SUBR d3,d2
PUSHR d3
LOADD d2,1
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 852; return End
LOADD d2,2; Case block AND return Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
COMPAREV d2,256
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 800
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 820
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,7
PUSHR d2
LOADD d2,3
POP d3
ADDR d2,d3
ADDV d2,7
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0.0001
GOTOMORE 835
LOADD d2,2; InlineFunc[bool Screen->isSolid(int, int)] Params Start
PUSHR d2
LOADD d2,5
POP d3
ADDR d2,d3
PUSHR d2
LOADD d2,1
SETR d1,d2; InlineFunc[bool Screen->isSolid(int, int)] Params End
POP d0; InlineFunc[bool Screen->isSolid(int, int)] Body Start
ISSOLID d2; InlineFunc[bool Screen->isSolid(int, int)] Body End
CASTBOOLF d2
COMPAREV d2,0.0001
SETMOREI d2
COMPAREV d2,0
SETTRUEI d2
GOTO 852; return End
ALLOCATEMEMV d2,60; Case block
STORED d2,0
WRITEPODSTRING d2,"Invalid direction %d passed to CanWalk(x,y,dir,step,bool) \n"
LOADD d2,0; InlineFunc[void printf(char32)] Params Start
PUSHR d2
LOADD d2,6
PUSHVARGR d2; InlineFunc[void printf(char32)] Params End
PRINTFVARG; InlineFunc[void printf(char32)] Body Start
POP d5; InlineFunc[void printf(char32)] Body End
LOADD d3,0
DEALLOCATEMEMR d3
SETV d2,0; return Start
GOTO 852; return End
POPARGS d5,0.0009
RETURNFUNC; Func[bool CanWalk(int, int, int, int, bool)] Body End
SETR d4,SP; Func[int CenterLinkX()] Body Start
SETR d2,LINKX; return Start
ADDV d2,8
GOTO 858; return End
RETURNFUNC; Func[int CenterLinkX()] Body End
SETR d4,SP; Func[int CenterLinkY()] Body Start
SETR d2,LINKY; return Start
ADDV d2,8
GOTO 863; return End
RETURNFUNC; Func[int CenterLinkY()] Body End
SETR d4,SP; Func[int CenterX(FFC)] Body Start
LOADD d2,0; return Start
PUSHR d2
POP REFFFC
SETR d2,X
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
MULTV d2,8
SETV d2,8
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTWIDTH
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
GOTO 886; return End
POPARGS d5,0.0001
RETURNFUNC; Func[int CenterX(FFC)] Body End
SETR d4,SP; Func[int CenterY(FFC)] Body Start
LOADD d2,0; return Start
PUSHR d2
POP REFFFC
SETR d2,Y
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTHEIGHT
MULTV d2,8
SETV d2,8
PUSHR d2
LOADD d2,0
PUSHR d2
POP REFFFC
SETR d2,FFTHEIGHT
POP d3
MULTR d2,d3
POP d3
ADDR d2,d3
GOTO 910; return End
POPARGS d5,0.0001
RETURNFUNC; Func[int CenterY(FFC)] Body End
PUSHV 0; Func[void NoAction()] Body Start
SETR d4,SP
SETV d2,0; for() #6184 setup
STORED d2,0
LOADD d2,0; for() #6184 LoopTest
COMPAREV d2,14
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 955; for() #6184 TestFail?
LOADD d2,0; if() #6187 Test AND for() #6184 Body Start
COMPAREV d2,9
SETTRUEI d2
SETV d2,0
COMPAREV d2,0
GOTOTRUE 930; Test 'if'
GOTO 951; continue #6186 AND if() #6187 Body
LOADD d2,0; if() #6188 Test
COMPAREV d2,6
SETTRUEI d2
SETV d2,0
COMPAREV d2,0
GOTOTRUE 937; Test 'if'
GOTO 951; continue #6186 AND if() #6188 Body
SETV d2,0
PUSHR d2
LOADD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONINPUT,d2
SETV d2,0
PUSHR d2
LOADD d2,0
PUSHR d2
POP d0
POP d2
SETR BUTTONPRESS,d2; for() #6184 Body End
LOADD d2,0; for() #6184 LoopIncrement
ADDV d2,1
STORED d2,0
GOTO 916; for() #6184 End
POPARGS d5,0.0001
RETURNFUNC; Func[void NoAction()] Body End
SETR d4,SP; Func[int VectorX(int, int)] Body Start
LOADD d2,0; InlineFunc[int Cos(int)] Params Start AND return Start
SETR d3,d2; InlineFunc[int Cos(int)] Params End
COSR d2,d3; InlineFunc[int Cos(int)] Body
PUSHR d2
LOADD d2,1
POP d3
MULTR d2,d3
GOTO 966; return End
POPARGS d5,0.0002
RETURNFUNC; Func[int VectorX(int, int)] Body End
SETR d4,SP; Func[int VectorY(int, int)] Body Start
LOADD d2,0; InlineFunc[int Sin(int)] Params Start AND return Start
SETR d3,d2; InlineFunc[int Sin(int)] Params End
SINR d2,d3; InlineFunc[int Sin(int)] Body
PUSHR d2
LOADD d2,1
POP d3
MULTR d2,d3
GOTO 977; return End
POPARGS d5,0.0002
RETURNFUNC; Func[int VectorY(int, int)] Body End
SETR d4,SP; Func[int Sign(int)] Body Start
LOADD d2,0; if() #7485 Test
COMPAREV d2,0
SETLESS d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 989; Test 'if'
SETV d2,1; return Start AND if() #7485 Body Start
GOTO 1000; return End AND if() #7485 Body End
LOADD d2,0; if() #7487 Test AND if() #7485 Else Start
COMPAREV d2,0
SETMORE d2
COMPAREV d2,0
SETTRUEI d2
COMPAREV d2,0
GOTOTRUE 998; Test 'if'
SETV d2,-1; return Start AND if() #7487 Body Start
GOTO 1000; return End AND if() #7487 Body End
SETV d2,0; return Start AND if() #7487 Else Start
GOTO 1000; return End AND if() #7487 Else End
POPARGS d5,0.0001; if() #7485 Else End
RETURNFUNC; Func[int Sign(int)] Body End


ALLOCATEGMEMV d2,4096; void run() Body Start
SETR gd1,d2
QUIT; void run() Body End